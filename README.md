# Assembly_Language_Study
B站鱼C汇编语言视频自学笔记

视频链接：https://www.bilibili.com/video/BV1Rs411c7HG?p=77

[TOC]
# 1. 基础知识
汇编语言是直接在硬件之上工作的编程语言，首先要了解硬件系统的结构，才能有效的应用汇编语言对其编程。

## 1.1 机器语言
机器语言是机器指令的集合，是一台机器可以正确执行的命令。

## 1.2 汇编语言的产生
汇编语言的主体是汇编指令。<br>
汇编指令和机器指令的差别在于指令的表示方法上。<br>
汇编指令是机器指令的助记符<br>
寄存器：简单的讲是CPU中可以存储数据的器件，一个CPU中有多个寄存器。

## 1.3 汇编语言的组成
汇编语言由以下三类组成：
  - 汇编指令（机器码的助记符）
  - 伪指令（由编译器执行）
  - 其他符号（由编译器识别）加减乘除等

汇编语言的核心是汇编指令，它决定了汇编语言的特性。

## 1.4 存储器
CPU是计算机的核心部件，他控制整个计算机的运作并进行运算，要想让一个CPU工作，就必须向它提供指令和数据，指令和数据在存储器中存放，也就是平时所说的内存。<br>
磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被CPU使用。

## 1.5 指令和数据
指令和数据是应用上的概念，在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。也就是说，同样的数据作为指令和数据会表示不同的含义。（由底层电路控制）

## 1.6 存储单元
存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号；

## 1.7 CPU对存储器的读写
CPU要想进行数据的读写，必须和外部期间进行三类信息的交互：
  - 存储单元的地址（地址信息）
  - 器件的选择，读或写命令（控制信息）
  - 读或写的数据（数据信息）

在计算机中专门有连接CPU和其他芯片的导线，通常称为总线
  - 物理上：一根根导线的集合；
  - 逻辑上划分为：
    - 地址总线（地址总线的宽度决定了CPU的寻址能力）
    - 数据总线（数据总线的宽度决定了CPU与其他期间进行数据传送时一次数据传送量）
    - 控制总线（控制总线宽度决定了CPU对系统中其他期间的控制能力）

## 1.8 地址总线
CPU是通过地址总线来指定存储单元的。<br>
地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。<br>
如果想要内存达到64位的速度，必须要有，缺一不可：
  - 64位的CPU
  - 64位的操作系统
  - 64位的软件

一个CPU有N根地址总线，则可以说这个CPU的地址总线的宽度为N。

## 1.9 数据总线
CPU与内存或其他器件之间的数据传送是通过数据总线来进行的。<br>
数据总线的宽度决定了CPU和外界的数据传送速度。

## 1.10 控制总线
CPU对外部期间的控制时通过控制总线来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。<br>
有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。<br>
所以，控制总线的宽度决定了CPU对外部器件的控制能力。

前面所讲的内存读或写命令是由几根控制线综合发出的：
  - 其中有一根名为读信号输出控制线负责由CPU向外传送读信号，CPU向该控制线上输出低电平表示将要读取数据；
  - 有一根名为写信号输出控制线负责由CPU向外传送写信号。

## 1.11 内存地址空间
一个CPU的地址线宽度为10，那么可以寻址1024个内存单元，这1024个可寻到的内存单元就构成这个CPU的内存地址空间。<br>
首先需要介绍两部分基本知识，主板和接口卡。

### 1.11.1 主板
每一台PC中，都有一个主板，主板上有核心器件和一些主要器件。<br>
这些器件通过总线相连。

### 1.11.2 接口卡
计算机系统中，所有可用程序控制其工作的设备，必须受到CPU的控制。<br>
CPU对外部设备不能直接控制，如显示器、音箱、打印机等。直接控制这些设备进行工作的是插在扩展插槽上的接口卡。

### 1.11.3 各类存储器芯片
从读写属性上看分为两类：
  - 随机存储器（RAM）
  - 只读存储器（ROM）

从功能和连接上分类：
  - 随机存储器RAM
  - 装有BIOS的ROM
  - 接口卡上的RAM

上述的那些存储器在物理上是独立的器件。<br>
但是他们在以下两点上相同：
  - 都和CPU的总线相连。
  - CPU对他们进行读或写的时候都通过控制线发出内存读写命令。

最终运行程序的是CPU，我们用汇编编程的时候，必须要从CPU角度考虑问题。<br>
对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间。

# 2. 寄存器（CPU工作原理）
一个典型的CPU由运算器、控制器、寄存器等器件组成，这些器件靠内部总线相连。<br>

区别：
  - 内部总线实现CPU内部各个器件之间的联系。
  - 外部总线实现CPU和主板上其他器件的联系。

8086 CPU有14个寄存器，他们的名称为：AX, BX, CX, DX, SI, DI, SP, BP, IP, CS, SS, DS, ES, PSW。

## 2.1 通用寄存器
8086CPU所有的寄存器都是16位的，可以存放两个字节。<br>
AX, BX, CX, DX通常用来存放一般性数据，所以被称为通用寄存器。<br>
8086上一代CPU中的寄存器都是8位的；<br>
为保证兼容性，这四个寄存器都可以分为两个独立的8位寄存器使用。
  - AX可以分为AH和AL；
  - BX可以分为BH和BL；
  - CX可以分为CH和CL；
  - DX可以分为DH和DL；

## 2.2 字在寄存器中的存储
一个字可以存在一个16位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高8位寄存器和低8位寄存器中。

## 2.3 几条汇编指令
```
汇编指令     控制CPU完成的操作                   用高级语言的语法描述
————————————————————————————————————————————————————————————————————————————————
mov ax,18   将18送入AX                          AX = 18
mov ah,78   将78送入AH                          AH = 78
add ax,8    将寄存器AX中的数值加上8              AX = AX + 8
mov ax,bx   将寄存器BX中的数据送入寄存器AX        AX = BX
add ax,bx   将AX，BX中的内容相加，结果存在AX中    AX = AX + BX
```
汇编指令不区分大小写<br>
数据溢出丢失，指的是进位值不能在8位寄存器中保存，但是CPU并不是真的丢弃这个进位值。

## 2.4 物理地址
CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间。<br>
我们将这个唯一的地址称为物理地址。

## 2.5 16位结构的CPU
概括的讲，16位结构描述了一个CPU具有以下几个方面特征：
1. 运算器一次最多可以处理16位的数据。
2. 寄存器的最大宽度为16位。
3. 寄存器和运算器之间的通路是16位的。

## 2.6 8086CPU给出物理地址的方法
8086有20位地址总线，可传送20位地址，寻址能力为1M。<br>
8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力却只有64K。<br>

Q：那么8086CPU如何用内部16位的数据转换成20位的地址呢？

A：8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。
1. CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址；
2. 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件；
3. 地址加法器将两个16位地址合并成一个20位的地址；
4. ...

### 2.6.1 地址加法器工作原理
地址加法器合成物理地址的方法：物理地址 = 段地址*16【即二进制数左移四位】 + 偏移地址

## 2.7 段的概念
内存没有分段，段的划分来自于CPU，由于8086CPU用“段地址*16 + 偏移地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。

在编程时，可以根据需要，将若干地址连续的内存单元看作一个端，用段地址*16定位段的起始地址，用偏移地址定位段中的内存单元。

## 2.8 段寄存器
段寄存器就是提供段地址的。<br>
8086CPU有4个段寄存器：CS,DS,SS,ES。<br>
当8086CPU要访问内存时，由这4个段寄存器提供内存单元的段地址。

## 2.9 CS和IP
CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。
  - CS为代码段寄存器
  - IP为指令指针寄存器

8086PC工作过程的简要描述
1. 从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器
2. IP = IP+所读取指令的长度，从而指向下一条指令
3. 执行指令，转到步骤1，重复这个过程
- 在8086CPU加电启动或复位后（即CPU刚开始工作时），CS和IP被设置为CS = FFFF，IP = 0000。
- 即在8086PC机刚启动是，CPU从内存FFFF0单元中读取指令执行。
- FFFF0单元中的指令是8086PC机开机后执行的第一条指令。 

在任何时候，CPU将CS、IP中的内容当做指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行。

如果说，内存中的一段信息曾被CPU执行过的话，那么，它所在的内存单元必然被CS：IP指向过。

## 2.10 修改CS、IP的指令
在CPU中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器的内容实现对CPU的控制。

CPU从何处执行指令是由CS、IP中的内容决定的，程序员可以通过改变CS、IP中的内容来控制CPU执行目标指令。

那么如何修改CS、IP的值呢？
1. MOV指令不能用于设置CS、IP的值，8086CPU没有提供这样的功能。
2. 8086CPU通过转移指令jmp修改CS、IP的内容：
   - jmp 段地址：偏移地址 -> CS<<4 + IP
   - 功能：用指令中给出的段地址修改CS，偏移地址修改IP。
3. 仅修改IP的内容：
   - jmp 某一合法寄存器：jmp ax（类似于mov IP，ax）
   - 功能：用寄存器中的值修改IP。

## 2.11 代码段
对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。

可以将长度为N(N<=64KB)的一组代码，存在一组地址连续、其实地址为16的倍数的内存单元中，这段内存是用来存放代码的，从而定义了一个代码段。

如何使得代码段中的指令被执行？
- 将一段内存当做代码段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就自动地将我们定义的代码段中的指令当做指令来执行。
- CPU只认被CS：IP指向的内存单元中的内容为指令。
- 所以要将CS:IP指向所定义的代码段中的第一条指令的首地址。

# 3. 寄存器（内存访问）
## 3.1 内存中字的存储
任何两个地址连续的内存单元，N号单元和N+1号单元，可以将它们看成两个内存单元，也可以看成一个地址为N的字单元中的高位字节单元和低位字节单元。

## 3.2 DS和address
CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址。

8086CPU中有一个DS寄存器，通常用来存放要访问的数据的段地址。

例如：我们要读取10000H单元的内容可以用如下程序段进行：
```
mov bx,1000
mov ds,bx
mov al,[0]
```
上面三条指令将10000H（1000：0）中的数据读到al中。

已知的mov指令可完成的两种传送功能：
1. 将数据直接送入寄存器；
2. 讲一个寄存器中的内容送入另一个寄存器中。
3. 除此之外，mov指令还可以将一个内存单元中的内容送入一个寄存器。

执行指令时，8086CPU自动取DS中的数据为内存单元的**段地址**。

8086CPU不支持将数据直接送入段寄存器的操作，DS是一个段寄存器。（硬件设计的问题）

数据->通用寄存器->段寄存器

## 3.3 字的传送
因为8086CPU是16位结构，有16根数据线，所以，可以一次性传送16位的数据，也就是一次性传送一个字。

## 3.4 mov、add、sub指令
已学mov指令的几种形式：
  - mov 寄存器，数据
  - mov 寄存器，寄存器
  - mov 寄存器，内存单元
  - mov 内存单元，寄存器
  - mov 段寄存器，寄存器

add和sub指令同mov一样，都有两个操作对象：
  - add 寄存器，数据
  - add 寄存器，寄存器
  - add 寄存器，内存单元
  - add 内存单元，寄存器
  - sub 寄存器，数据
  - sub 寄存器，寄存器
  - sub 寄存器，内存单元
  - sub 内存单元，寄存器

## 3.5 数据段
我们可以将一组长度为N(N<=64K)、地址连续、起始地址为16的倍数的内存单元当做专门存储数据的内存空间，从而定义了一个数据段。

如何访问数据段中的数据呢？
  - 将一段内存当做数据段，是我们在编程时的一种安排，我们可以在具体操作的时候，用ds存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。

## 3.6 栈
栈是一种具有特殊的访问方式的存储空间。它的特殊性就在于，最后进入这个空间的数据，最先出去。

栈有两个基本的操作：入栈和出栈
  - 入栈：讲一个新的元素放到栈顶；
  - 出栈：从栈顶取出一个元素。

栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。

### 3.6.1 CPU提供的栈机制
现今的CPU中都有栈的设计。

8086CPU提供相关的指令来以栈的方式访问内存空间。

这意味着，我们在基于8086CPU编程的时候，可以将一段内存当做栈来使用。

8086CPU提供入栈和出栈指令：
  - PUSH 入栈
  - POP 出栈

push ax：将寄存器ax中的数据送入栈中。

pop ax：从栈顶取出数据送入ax。

8086CPU的入栈和出栈操作都是以字为单位进行的。在内存当中，高位表示栈底，低位表示栈顶。

1.CPU如何知道一段内存空间被当做栈使用？
   - 寄存器CS和IP中存放着当前指令的段地址和偏移地址。

2.执行push和pop的时候，如何知道哪个单元是栈顶单元？
   - 在8086CPU中，有两个寄存器：段寄存器SS（存放栈顶的段地址）和寄存器SP（存放栈顶的偏移地址），任意时刻，SS:SP指向栈顶元素。
   - 当执行push ax时，CPU内部执行如下操作：
     - SP=SP-2；
     - 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。
   - 当执行pop ax时，CPU内部执行如下操作：
     - 将SS:SP指向的内存单元处的数据送入ax中；
     - SP=SP+2,SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。

结论：任意时刻，SS:SP指向栈顶元素。

当一个栈为空时，其SP指针将指向最高地址单元的下一个单元。

出栈后，SS:SP指向新的栈顶1000EH，pop操作前的栈顶元素，1000CH处的数据依然存在，但是，它已不再栈中。当再次执行push等入栈指令后，SS:SP移至1000CH，并在里面写入新的数据，它将被覆盖。

**小结：**<br>
1. 任意时刻，SS:SP指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素。
2. 所以SS:SP智能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址+2.
3. 栈最底部字单元的地址为1000：000E，所以栈空时，SP=0010H。

### 3.6.2 栈顶超界的问题
如何能够保证在入栈、出栈时，栈顶不会超出栈空间？
  - 栈顶超界是危险的：因为我们既然将一段空间安排为栈，那么在栈空间之外的空间里面很可能存放了具有其他用途的数据、代码等，这些数据、代码可能是我们自己的程序中的，也可能是别的程序中的。
  - 8086CPU不保证对栈的操作不会超界。这就是说，8086CPU只知道栈顶在何处，而不知道读者安排的占空间有多大。这点就好像，CPU只知道当前要执行的指令在何处而不知道读者要执行的指令有多少。
  - 所以，8086CPU的工作机理，只考虑当前的情况：
    - 当前栈顶在何处；
    - 当前要执行的指令是哪一条。

### 3.6.3 栈与内存
栈空间也是内存空间的一部分，它只是一段可以以一种特殊的方式进行访问的内存空间。

编程：将10000H-1000FH这段空间当做栈，初始状态是空的，将AX,BX,DS中的数据入栈。
```
mov ax, 1000;
mov ss,ax;
mov sp,0010;
push ax;
push bx;
push ds;
```

结论：push、pop实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。

### 3.6.4 栈段
我们可以将长度为N(N<=64K)的一组地址连续、起始地址为16的倍数的内存单元，当做栈来用，从而定义了一个栈段。

一个栈段最大可以设为多少？为什么？
  - 栈顶的变化范围是0-FFFFH，从栈空的时候的SP=0，一直压栈，直到栈满时SP=0；如果再次压栈，栈顶将环绕，覆盖了原来栈中的内容。
  - 所以一个栈段的容量最大为64KB

一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么都不是。关键在于CPU中寄存器的设置，即：CS,IP,SS,SP,DS的指向。

# 4. 第一个程序
## 4.1 一个源程序从写出到执行的过程
一个汇编语言程序从写出到最终执行的简要过程：
  - 编写
  - 编译链接
    - 使用汇编语言编译程序（MASM.EXE）对源程序文件中的源程序进行编译，产生目标文件；
    - 在用链接程序（LINK.EXE）对目标文件进行链接，生成可在操作系统中直接运行的可执行文件。
  - 执行
    - 操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如：设置CS:IP指向第一条要执行的指令），然后由CPU执行程序。

## 4.2 源程序
汇编指令：有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。

伪指令：没有对应机器码的指令，最终不被CPU所执行。伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。

如何定义一个段？
  - segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。
  - segment和ends的功能是定义一个段，segment说明一个段开始，ends说明一个段结束。
  - 一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当做栈空间使用。
  - 一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。

end是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译。

如果程序写完了，要在结尾处加上伪指令end。否则，编译器在编译程序时，无法知道程序在何处结束。

**切记：**
不要搞混end和ends。

assume：含义为“假设”。
  - 它假设某一段寄存器和程序中的某一个用segment...ends定义的段相关联。
  - 通过assume说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。

我们可以将源程序文件中的所有内容称为源程序，将源程序中最终由计算机执行处理的指令或数据，称为程序。

程序最先以汇编指令的形式存在源程序中，经编译、链接后转变为机器码，存储在可执行文件中。

标号：
  - 一个标号指代了一个地址。
  - codesg：放在segment前面，作为一个段的名称，这个段的名称最终将被编译、链接程序处理为一个段的段地址。

程序返回：一个程序结束后，将CPU的控制权交还给使它运行的程序，我们称这个过程为：**程序返回**。
  - 如何返回？
    - 应该在程序的末尾添加返回的程序段。
    - 这两条指令所实现的功能就是程序返回
```
mov ax,4c00
int 21
```

## 4.3 编译和链接
链接的作用：
  - 当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译称为目标文件后，再用链接程序将它们链接到一起，生成一个可执行文件；
  - 程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件。
  - 一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，链接程序将此内容处理为最终的可执行信息。
  - 所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用链接程序对目标文件进行处理，生成可执行文件。

我们用汇编语言编程，就要用到：编辑器、编译器、链接器、调试工具等所有工具，而这些工具都是操作系统之上运行的程序，所以我们的学习过程必须在操作系统的环境中进行。

## 4.4 可执行文件汇总的程序装入内存并运行的原理
在DOS中，可执行文件中的程序P1若要运行，必须有一个正在运行的程序P2，将P1从可执行文件中加载入内存，将CPU的控制权交给它，P1才能得以运行；

当P1运行完毕后，应该将CPU的控制权交还给使它得以运行的程序P2。

### 4.4.1 操作系统的外壳
操作系统是由多个功能模块组成的庞大、复杂的软件系统。任何通用的操作系统，都要提供一个称为shell的程序，用户使用这个程序来操作计算机系统工作。

DOS中有一个程序command.com，这个程序在DOS中称为命令解释器，也就是DOS系统的shell。

### 4.4.2 汇编程序从写出到执行的过程
编程->1.asm->编译->1.obj->链接->1.exe->加载->内存中的程序->运行

## 4.5 程序执行过程的跟踪
为了观察程序的运行过程，我们可以使用debug。

debug可以将程序加载入内存，设置CS:IP指向程序的入口，但debug并不放弃对CPU的控制，这样，我们就可以使用debug的相关命令来单步执行程序，查看每条指令的执行结果。

# 5. [BX]和loop指令
## 5.1 [bx]
[bx]是什么呢？
  - 和[0]有些类似，[0]表示内存单元，它的偏移地址是0。

我们要完整地描述一个内存单元，需要两种信息：
  - 内存单元的地址；
  - 内存单元的长度（类型）

我们用[0]表示一个内存单元是，0表示单元的便宜地址，段地址默认在ds中，单元的长度可以由具体指令中的其他操作对象指出，如AX,AL。

[bx]同样也表示一个内存单元，它的偏移地址在bx中，如mov ax，[bx]

描述性符号"()"

约定符号idata表示常量

mov ax,[bx]
功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中。
## 5.2 Loop指令
CPU执行loop指令的时候，要进行两步操作：
  - (cx)=(cx)-1
  - 判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。

编程计算2^12实现代码：
```
assume cs:code
code segment
start： 
    mov ax,2
    mov cx,11
s:  add ax,ax
    loop s

    mov ax,4c00h
    int 21h
code ends
end start
```

## 5.3 在debug中跟踪用loop指令实现的循环程序
在汇编源程序中，数据不能以字母开头，所以要在前面加0。

## 5.4 debug和汇编编译器Masm对指令的不同处理
在MASM中，mov ax，[0] 与 mov ax，0相同。

## 5.5 loop和[bx]的联合应用
我们将内存单元中的8位数据赋值到一个16位寄存器ax中，再将ax中的数据加到dx上，从而使两个运算对象的类型匹配并且结果不会超界。

在实际编程中，经常会遇到，用同一种方法处理地址连续的内存单元中的数据的问题。

我们需要用循环来解决这类问题，同时我们必须能够在每次循环的时候按照同一种方法来改变要访问的内存单元的地址。

mov al,[bx]中的bx就可以看作一个代表内存单元地址的变量，我们可以不写新的指令，仅通过改变bx中的数值，改变指令访问的内存单元。

## 5.6 段前缀
指令mov ax,[bx]中，内存单元的偏移地址由bx给出，而段地址默认在ds中

我们可以在访问内存单元的指令中显式的给出内存单元的段地址所在的段寄存器。

这些出现在访问内存单元的指令中，用于显式的指明内存单元的段地址的ds：，cs：，ss：，在汇编语言中称为段前缀。

## 5.7 一段安全的空间
在8086模式中，随意向一段内存空间写入内容是很危险的，因为这段空间中可能存放着重要的系统数据或代码。

我们在不能确定一段内存空间中是否存放着重要的数据或代码的时候，不能随意向其中写入内容。

在一般的PC机中，DOS方式下，DOS和其他合法的程序一般都不会使用0:200~0:2FF的256个字节的空间。所以，我们使用这段空间是安全的。

## 5.8 段前缀的使用
在访问内存单元的指令mov es:[bx],al中，显式的用段前缀es：给出单元的段地址，这样就不必在循环中重复设置ds。

# 6. 包含多个段的程序
## 6.1 在代码段中使用数据
编程计算一下8个数据的和，结果存在ax寄存器中：0123，0456，0789，0abc，0def，0fed，0cba，0987.
```
assume cs:codesg
codesg segment
    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
    mov bx,0
    mov ax,0
    mov cx,8
s:  add ax,cs:[bx]
    add bx,2
    loop s
    mov ax,4c00h
    int 21h
codesg ends
end
```

程序第一行中的dw的含义是定义字型数据。dw即define word。

这8个数据的偏移地址是多少呢？
  - 因为用dw定义的数据处于代码段的最开始，所以偏移地址为0，这8个数据就在代码段的偏移0、2、4、6、8、A、C、E处。

在代码段中存放了数据后，若要让程序指向真正代码的第一行，需要添加标号XXX，并且在结尾添加end XXX。

## 6.2 在代码段中使用栈
我们可以在程序中通过定义数据来取得一段空间，然后将这段空间当做栈空间来用。

## 6.3 将数据、代码、栈放入不同的段
我们在程序中用到了数据和栈，我们将数据、栈和代码都放到了一个段里面。我们在编程的时候要注意何处是数据，何处是栈，何处是代码。

这样做显然有两个问题：
  - 把它们放到一个段中使程序显得混乱；
  - 前面程序中处理的数据很少，用到的栈空间也小，加上没有多长的代码，放到一个段里面没有问题。

如果数据、栈和代码需要的空间超过64KB，就不能放在一个段中（一个段的容量不能大于64KB，是我们在学习中所用的8086模式的限制，并不是所有的处理器都这样）。

所以，我们应该考虑用多个段来存放数据、代码和栈。
  - 我们用和定义代码段一样的方法来定义多个段，然后在这些段里面定义需要的数据，或通过定义数据来取得栈空间。

如代码：
```
assume cs:code,ds:data,ss:stack

data segment
    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
data ends

stack segment
    dw 0,0,0,0,0,0,0,0
stack ends

code segment
start:
    mov ax,stack
    mov sp,16
    mov ax,data
    mov ds,ax
    mov bx,0
    mov cx,8
s:  push [bx]
    add bx,2
    loop s

    mov bx,0
    mov cx,8
s0: pop [bx]
    add bx,2
    loop s0

    mov ax,4c00h
    int 21h
code ends
end start
```

1. 我们在源程序中为者三个段齐了具有含义的名称，用来存放数据的段我们将命名为data，用来放代码的段我们将其命名为code，用来作栈空间的命名为stack。
2. 我们在源程序中用伪指令assume cs:code,ds:data,ss:stack将cs，ds和ss分别和code，data和stack段相连。
3. 若要CPU按照我们的安排行事，就要用机器指令控制它，源程序中的汇编指令是CPU要执行的内容。

那么，CPU如何知道去执行他们？
  - 我们在源程序的最后用end start说明了程序的入口，这个入口将被写入可执行文件的描述信息，可执行文件中的程序被加载入内存后，CPU的CS:IP被设置指向这个入口，从而开始执行程序汇总的第一条指令。
  - 标号start在code段中，这样CPU就将code段中的内容当做指令来执行了。
  - 设置ss指向stack，设置ss:sp指向stack：16，CPU执行这些指令后，将把stack段当做栈空间来用。
  - CPU若要访问data段中的数据，则可用ds指向data段，用其他的寄存器（如：bx）来存放data段中数据的偏移地址。

总之，CPU到底如何处理我们定义的段中的内容，是当做指令执行，当做数据访问，还是当做栈空间，完全是靠程序中具体的汇编指令和汇编指令对CS:IP,SS:SP,DS等寄存器的设置来决定的。

# 7. 更灵活的定位内存地址的方法
## 7.1 and和or指令
and指令：逻辑与指令，按位进行与运算

通过该指令可将操作对象的相应位设为0，其他位不变。
  - 例如，将al的第6位设为0：and al,10111111B

or指令：逻辑或指令，按位进行或运算

通过该指令可将操作对象的相应位设为1，其他位不变。

## 7.2 关于ASCII码
世界上有很多编码方案，有种方案叫做ASCII编码，是在计算机系统中通常被采用的。

简单地说，所谓编码方案，就是一套规则，他约定了用什么样的信息来表示现实对象。

## 7.3 以字符形式给出的数据
我们可以在汇编程序中，用'......'的方式指明数据是以字符的形式给出的，编译器将把他们转化为相对应的ASCII码。

## 7.4 大小写转换的问题
我们可以将所有的字母的大写字符和小写字符所对应的ASCII码列出来，进行对比，从中找到规律。

通过对比，我们可以看出来，小写字母的ASCII码值比大写字母的ASCII码值大20H。

**可以通过按位与的方式，将字母的第五位置零或置1来进行大小写转换。**

## 7.5 [bx+idata]
在前面，我们可以用[bx]的方式来指明一个内存单元，我们还可以用一种更为灵活的方式来指明内存单元：
  - [bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata（bx中的数值加上idata）。

mov ax,[bx+200]的含义：
  - 将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，偏移地址为bx中的数值加上200，段地址在ds中。
  - 数学化的描述为：(ax)=((ds)*16+(bx)+200)

mov ax,[bx+200]也可以写成如下格式：
  - mov ax,[200+bx]
  - mov ax,200[bx]
  - mov ax,[bx].200

## 7.6 用[bx+idata]的方式进行数组的处理
我们可以用[0+bx]和[5+bx]的方式在同一个循环中定位这两个字符串中的字符。

在这里，0和5给定了两个字符串的起始偏移地址，bx中给出了从起始偏移地址开始的相对地址。

这两个字符串在内存中的起始地址是不一样的，但是，他们中的每一个字符，从起始地址开始的相对地址的变化是相同的。

## 7.7 SI和DI
SI和DI是8086CPU中和bx功能相近的寄存器，但是SI和DI不能够分成两个8位寄存器来使用。

我们可以用ds:si指向要复制的原始字符串，用ds:di指向复制的目的空间，然后用一个循环来完成复制。

## 7.8 [bx+si]和[bx+di]
[bx+si]表示一个内存单元，它的偏移地址为(bx)+(si)（即bx中的数值加上si中的数值）。

mov ax,[bx+si]的含义：
  - 将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，偏移地址为bx中的数值加上si中的数值，段地址在ds中。
  - 也可以写成mov ax,[bx][si]

## 7.9 [bx+si+idata]和[bx+di+idata]
[bx+si+idata]表示一个内存单元，它的便宜地址为(bx)+(si)+(idata)。

mov ax,[bx+si+idata]的含义：
  - 讲一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，偏移地址为bx中的数值加上si中的数值再加上idata，段地址在ds中。
  - 也可以写成mov ax,200[bx][si]
  - mov ax,[bx].200[si]

## 7.10 不同的寻址方式的灵活应用
如果我们比较一下前面用到的几种定位内存地址的方法（可称为寻址方式），就可以发现有以下几种方式：
  - [idata]用一个常量来表示地址，可用于直接定位一个内存单元
  - [bx]用一个变量来表示内存地址，可用于间接定位一个内存单元
  - [bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元
  - [bx+si]用两个变量表示地址
  - [bx+si+idata]用两个变量和一个常量表示地址

从[idata]一直到[bx+si+idata]，我们可以用更加灵活的方式定位一个内存单元的地址。这使我们可以从更加结构化的角度来看待所要处理的数据。

在循环嵌套的问题中，由于cx和loop绑定无法使用另一个变量作为循环计数，应该怎么办？
  - 我们应该在每次开始内层循环的时候，将外层循环的cs中的额数值保存起来，在执行外层循环的loop指令前，再回复外层循环的cx数值。
  - 我们可以用寄存器dx来临时保存cx中的数值。

如果在内层循环中，dx寄存器（或其他所有寄存器）也被使用，该怎么办？
  - 我们可以用寄存器暂存它们，但是这不是一个一般化的解决方案，因为寄存器的数量有限，每个程序中可使用的寄存器都不一样。
  - 可以使用内存单元来保存数据，但是却有些麻烦，因为如果需要保存多个数据的时候，读者必须要记住数据放到了那个单元中，这样程序容易混乱。
  - 一般来说，在需要暂存数据的时候，我们都应该使用栈。

# 8. 数据处理的两个基本问题
计算机是进行数据处理、运算的机器，那么有两个基本的问题就包含在其中：
  - 处理的数据在什么地方？
  - 要处理的数据有多长？

为了描述上的简洁，我们将使用两个描述性的符号reg来表示一个寄存器，用sreg表示一个段寄存器。

## 8.1 bx、si、di、bp
1. 在8086CPU中，只有这4个寄存器可以用在[]中来进行内存单元的寻址。
2. 在[]中，这4个寄存器可以单个出现，或只能以四种组合出现：
   - bx和si、bx和di、bp和si、bp和di
3. 只要在[]中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中。比如：
   - mov ax,[bp]  含义：(ax)=((ss)*16+(bp))
   - mov ax,[bp+idata]  含义：(ax)=((ss)*16+(bp)+idata)
  
## 8.2 机器指令处理的数据所在位置
绝大部分机器指令都是进行数据处理的指令，处理大致可分为三类：读取、写入、运算。

在机器指令这一层来讲，并不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。

指令在执行前，所要处理的数据可以在三个地方：
  - CPU内部、内存、端口

## 8.3 汇编语言中数据位置的表达
汇编语言中用三个概念来表达数据的位置：
  - 立即数（idata）
  - 寄存器
  - 段地址(SA)和偏移地址(EA)

## 8.4 寻址方式
当数据存放在内存中的时候，我们可以用多种方式来给定这个内存单元的偏移地址，这种定位内存单元的方法一般被称为寻址方式。
- 直接寻址
- 寄存器简介寻址
- 寄存器相对寻址
- 基址变址寻址
- 相对基址变址寻址

## 8.5 指令要处理的数据有多长？
8086CPU的指令，可以处理两种尺寸的数据，byte和word。所以在机器指令中要指明，指令进行的是字操作还是字节操作。确定指令长度的方法：
  - 通过寄存器名指明要处理的数据的尺寸
    - 下面的指令中，寄存器指明了指令进行的是字操作：
      - mov ax,1
      - mov bx,ds:[0]
    - 下面的指令中，寄存器指明了指令进行的是字节操作：
      - mov al,1
      - mov al,bl
  - 在没有寄存器名存在的情况下，用操作符**X ptr**指明内存单元的长度，X在汇编指令中可以为word或byte
    - 下面的指令中，用word ptr指明了指令访问的内存单元是一个字单元：
      - mov word ptr ds:[0],1
      - mov word ptr [bx]
    - 下面的指令中，用byte ptr指明了指令访问的内存单元是一个字节单元
      - mov byte ptr ds:[0],1
      - mov byte ptr [bx]
  - 其他方法
    - 有些指令默认了访问的是字单元还是字单元，比如：push[1000H]就不用指明访问的是字单元还是字节单元，因为push指令只进行字操作。

## 8.6 寻址方式的综合应用
8086CPU提供的如[bx+si+idata]的寻址方式为结构化数据的处理提供了方便。

是的我们可以在编程的时候，从结构化的角度去看待所要处理的数据。

从上面我们可以看到，一个结构化的数据包含了多个数据项，而数据项的类型又不相同，有的是字型数据，有的是字节型数据。有的是数组（字符串）。

一般来说，我们可以用[bx+si+idata]的方式来访问结构体中的数据。
  - 用bx定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组项中的每个元素。

## 8.7 div指令
div是除法指令，使用div作除法的时候：
  - 除数：8位或16位，在寄存器或内存单元中
  - 被除数：默认放在AX或DX和AX中

运算结果：
  - 8位：商放在AL，余数放在AH
  - 16位：商放在AX，余数放在DX

div指令格式：
  - div reg
  - div 内存单元
    - div byte ptr ds:[0];
    - 含义为：(al)=(ax)/((ds)*16+0)的商；
    - (ah)=(ax)/((ds)*16+0)的余数
## 8.8 伪指令dd
dd是用来定义dword行数据的。32位

## 8.9 dup
dup是一个操作符，在汇编语言中同db、dw、dd等一样，也是由编译器识别处理的符号。

它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复。

db 3 dup (0)
  - 定义了3个字节，他们的值都是0

db 3 dup (0,1,2)
  - 定义了9个字节，他们是0、1、2、0、1、2、0、1、2

如果没有dup，定义部分的程序就变得太长了，有了dup就可以轻松解决。

# 9. 转移指令的原理
8086CPU的转移指令分为以下几类：
  - 无条件转移指令
  - 条件转移指令
  - 循环指令
  - 过程
  - 中断

## 9.1 操作符offset
操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。

```
start: mov ax,offset start
```

## 9.2 jmp指令
jmp为无条件转移，可以只修改IP，也可以同时修改CS和IP；

jmp指令要给出两种信息：
  - 转移的目的地址
  - 转移的距离（段间转移、段内短转移、段内近转移）

## 9.3 依据位移进行转移的jmp指令
jmp short标号
  - 这种格式的jmp指令实现的是段内短转移，它对IP的修改范围为-128~127，也就是说，它向前转移时可以最多越过128个字节，向后转移可以最多越过127个字节。

在一般的汇编指令中，汇编指令中的idata（立即数），不论它是表示一个数据还是内存单元的偏移地址，都会在对应的机器指令中出现，因为CPU执行的是机器指令，它必须要处理这些数据或地址。

但是，jmp 0008或jmp short s所对应的机器码为EB03，这个机器码中竟不包含转移的目的地址。

这意味着，CPU在执行EB03的时候，并不知道转移目的地址。

那么，没有了目的地址，CPU如何知道转移到哪里呢？
  - 如果机器指令中不包含目的地址的话，那么，也就是说CPU不需要这个目的地址就可以实现对IP的修改。
  - 实际上，“jmp short 标号”的功能为(IP)=(IP)+8位位移。
    - 8位位移=“标号”处的地址-jmp指令后的第一个字节的地址
    - short指明此处的位移为8位位移
    - 8位位移的范围为-128~127，用补码表示
    - 8位位移由编译程序在编译时算出

还有一种和指令“jmp short 标号”功能相近的指令格式：
  - jmp near ptr 标号，他实现的是段内近转移
  - 功能为(IP)=(IP)+16位位移
    - 16位位移=“标号”处的地址-jmp指令后的第一个字节的地址
    - near ptr指明此处的位移为16位位移
    - 16位位移的范围为-32769~32767，用补码表示
    - 16位位移由编译程序在编译时算出

## 9.4 转移的目的地址在指令中的jmp指令
前面讲的jmp指令，其对应的机器码中并没有转移的目的地址，而是相对于当前IP的转移位移。

指令“jmp far ptr 标号”实现的是段间转移，又称为远转移。功能如下：
  - (CS)=标号所在段的段地址
  - (IP)=标号所在段中的偏移地址
  - far ptr指明了指令用标号的段地址和偏移地址修改CS和IP

jmp far ptr s在汇编程序debug中的含义为jmp OBBD:010B；其翻译的机器码为：EA0B01BD0B。
  - 源程序中的db 256 dup (0)，被debug解释为相应的若干条汇编指令。这不是关键，关键是，我们要注意一下jump far ptr s所对应的机器码：EA0B01BD0B，其中包含转移的目的地址。

## 9.5 转移地址在寄存器中的jmp指令
指令格式：jmp 16位寄存器
  - 功能：IP=（16位寄存器）

## 9.6 转移地址在内存中的jmp指令
转移地址在内存中的jmp指令有两种格式：
  - jmp word ptr 内存单元地址（段内转移）
    - 功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。
```
mov ax,0123H
mov ds:[0],ax
jmp word ptr ds:[0]
```
  - jmp dword ptr 内存单元地址（段间转移）
    - 功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。
    - (CS)=(内存单元地址+2)
    - (IP)=(内存单元地址)
```
mov ax, 0123H
mov ds:[0], ax
mov word ptr ds:[2], 0
jmp dword ptr ds:[0]
```

## 9.7 jcxz指令
jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的额机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127。

指令格式：jcxz 标号<br>
指令操作：
  - 当(cx)=0时，(IP)=(IP)+8位位移
    - 8位位移=“标号”处的地址-jcxz指令后的第一个字节的地址
    - 8位位移的范围为-128~127，用补码表示
    - 8位位移由编译程序在编译时算出
  - 当(cx)!=0时，什么也不做

## 9.8 loop指令
loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。

对IP的修改范围都为-128~127。

loop 标号指令操作：
  - (cx)=(cx)-1;
  - 如果(cx)!=0,(IP)=(IP)+8位位移
    - 8位位移=“标号”处的地址-jcxz指令后的第一个字节的地址
    - 8位位移的范围为-128~127，用补码表示
    - 8位位移由编译程序在编译时算出
  - 当(cx)=0，什么也不做

## 9.9 根据位移进行转移的意义
jmp short 标号<br>
jmp near ptr 标号<br>
jcxz 标号<br>
loop 标号<br>

前面讲到的几种汇编指令，他们对IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移距离。

这样设计，方便了程序段在内存中的浮动装配。

例如：
```
    mov cx,6
    mov ax,10
s:  add ax,ax
    loop s
```

这段程序装在内存中的不同位置都可正确执行，因为loop s在执行时只涉及到s的位移（-4，前移4个字节，补码表示为FCH），而不是s的地址。

## 9.10 编译器对转移位移超界的检测
根据位移进行位移的指令，它们的转移范围受到转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错。

# 10. call和ret指令
call和ret指令都是转移指令，他们都修改IP，或同时修改CS和IP。

他们经常被共同用来实现子程序的设计。

## 10.1 ret和retf
ret指令用栈中的数据，修改IP的内容，从而实现近转移。

CPU执行ret指令是，进行下面两步操作：
  - (IP)=((ss)*16+(sp))
  - (sp)=(sp)+2

retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移；

CPU执行retf指令是，进行下面两步操作：
  - (IP)=((ss)*16+(sp))
  - (sp)=(sp)+2
  - (cs)=((ss)*16+(sp))
  - (sp)=(sp)+2

## 10.2 call指令
call指令经常跟ret指令配合使用，因此CPU执行call指令，进行两步操作：
  - 将当前的IP或CS和IP压入栈中
  - 转移(jmp)

call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。

## 10.3 依据位移进行转移的call指令
call 标号：将当前的IP压栈后，转到标号处执行指令
  - CPU执行此种格式的call指令时，进行如下操作：
    - (sp)=(sp)-2
    - ((ss)*16+(sp))=(IP)
    - (IP)=(IP)+16位位移
  - 16位位移=“标号”处的地址-call指令后的第一个字节的地址
  - 16位位移的范围为-32769~32767，用补码表示
  - 16位位移由编译程序在编译时算出

如果用汇编语法来解释此种格式的call指令，则：
  - CPU执行指令“call 标号”时，相当于进行：
    - push IP
    - jmp near ptr 标号

## 10.4 转移的目的地址在指令中的call指令
前面讲解的call指令，其对应的机器指令中并没有转移的目的地址，而是相对于当前IP的转移位移。

指令“call far ptr 标号”实现的是段间转移。实际操作：
  - (sp)=(sp)-2
  - ((ss)*16+(sp))=(CS)
  - (sp)=(sp)-2
  - ((ss)*16+(sp))=(IP)
  - (CS)=标号所在的段地址
  - (IP)=标号所在的偏移地址

如果用汇编语法来解释此种格式的call指令，则：
  - CPU执行指令“call far ptr 标号”时，相当于进行：
    - push CS
    - push IP
    - jmp far ptr 标号

## 10.5 转移地址在寄存器中的call指令
指令格式：call 16位寄存器<br>
功能：
  - (sp)=(sp)-2
  - ((ss)*16+(sp))=(IP)
  - (IP)=(16位寄存器)

汇编语法解释此种格式的call指令，CPU执行call 16位reg时，相当于进行：
  - push IP
  - jmp 16位寄存器

## 10.6 转移地址在内存中的call指令
转移地址在内存中的call指令有两种格式：
  - call word ptr 内存单元地址
  - call dword ptr 内存单元地址

call word ptr 内存单元地址的汇编语法解释：
  - push IP
  - jmp word ptr 内存单元地址

实例：
```
mov sp,10h
mov ax,0123h
mov ds:[0],ax
call word ptr ds:[0]
```

call dword ptr 内存单元地址的汇编语法解释：
  - push CS
  - push IP
  - jmp dword ptr 内存单元地址

实例：
```
mov sp,10h
mov ax,0123h
mov ds:[0],ax
mov word ptr ds:[2],0
call dword ptr ds:[0]
```

## 10.7 call和ret的配合使用
配合使用实现了函数的调用和return

## 10.8 mul指令
mul是乘法指令，使用mul做乘法的时候：
  - 相乘的两个数，要么都是8位的，要么都是16位。
    - 8位：AL中和8位寄存器或内存字节单元中
    - 16位：AX中和16位寄存器或内存字单元中。
  - 相乘结果：
    - 8位：放在AX中
    - 16位：DX（高位）和AX（低位）中

格式：
  - mul reg
  - mul 内存单元

内存单元可以用不同的寻址方式给出，比如：
  - mul byte ptr ds:[0]
    - 含义为：(ax)=(al)*((ds)*16+0)
  - mul word ptr [bx+si+8]
    - 含义为：
    - (ax)=(ax)*((ds)*16+(bx)+(si)+8)结果的低16位
    - (dx)=(ax)*((ds)*16+(bx)+(si)+8)结果的高16位

## 10.9 模块化程序设计
call与ret指令共同支持了汇编语言编程中的模块化设计。在实际编程中，程序的模块化是必不可少的。

因为现实的问题比较复杂，对现实问题进行分析时，把它转化成为相互联系、不同层次的子问题，是必须的解决方法。

而call和ret指令对这种分析方法提供了程序实现上的支持。利用call和ret指令，我们可以用简介的方法，实现多个互相联系、功能独立的子程序来解决一个复杂的问题。

## 10.10 参数和结果传递的问题
子程序一般都要根据提供的参数处理一定的事物，处理后，将结果（返回值）提供给调用者。

其实，我们讨论参数和返回值传递的问题，实际上就是在探讨，应该如何存储子程序需要的参数和产生的返回值。

用寄存器来存储参数和结果是最常使用的方法。对于存放参数的寄存器和存放结果的寄存器，调用者和子程序的读写操作恰恰相反：
  - 调用者将参数送入参数寄存器，从结果寄存器中取到返回值；
  - 子程序从参数寄存器中取到参数，将返回值送入结果寄存器。

## 10.11 批量数据的传递
寄存器的数量终究有限，我们不可能简单地用寄存器来存放多个需要传递的数据。对于返回值，也有同样的问题。

在这种时候，我们将批量数据放到内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给需要的子程序。

对于具有批量数据的返回结果，也可用同样的方法。

## 10.12 寄存器冲突的问题
设计一个子程序：
  - 功能：将一个全是字母，以0结尾的字符串，转化为答谢。
  - 程序要处理的字符串以0作为结尾符，这个字符串可以如下定义：
    - db 'conversation',0

分析：
  - 应用这个子程序，字符串的内容后面定要有一个0，标记字符串的结束。子程序可以一次读取每个字符进行检测，如果不是0，就进行大写的转化，如果是0，就结束处理。
  - 由于可通过检测0而知道是否已经处理完整个字符串，所以子程序可以不需要字符串的长度作为参考。我们可以直接用jcxz来检测0。

# 11. 标志寄存器
8086CPU的标志寄存器有16位，其中存储的信息通常被称为程序状态字(PSW)。

flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。

而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。

8086CPU的flag寄存器的结构：

0：CF

1：

2：PF

3:

4：AF

5:

6:ZF

7:SF

8:TF

9:IF

10:DF

11:OF

12:

13:

14:

15:

flag的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义。而0、2、4、6、7、8、9、10、11位都具有特殊的含义。

## 11.1 ZF标志
flag的第六位是ZF(Zero Flag)，零标志位。它记录相关指令执行后，
  - 结果为0 ZF=1
  - 结果不为0 ZF=0

对于ZF的值，我们可以这样来看，ZF标记相关指令的计算结果是否为0，如果为0，则在ZF要记录下“是0”这样的肯定信息。

在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如add、sub、mul、div、inc、or、and等，他们大都是运算指令（进行逻辑或算是运算）；

有的指令的执行对标志寄存器没有影响，比如：mov、push、pop等，他们大都是传送指令。

我们在使用一条指令的时候，要注意这条指令的全部功能，其中包括，执行结果对标志寄存器的哪些标志位造成影响。

## 11.2 PF标志
flag的第2位时PF，奇偶校验位。它记录指令执行后，结果的所有二进制为中1的个数：
  - 为偶数，PF=1；
  - 为奇数，PF=0。

## 11.3 SF标志
flag的第7位时SF，符号标志位。它记录指令执行后，
  - 结果为负，SF=1
  - 结果为正，SF=0。

## 11.4 CF标志
flag的第0位时CF，进位标志位。它记录指令执行后，
  - 有进位，CF=1
  - 无进位，CF=0。

另外一种情况，当两个数据做减法的时候，有可能向更高为借位。

而flag的CF位也可以用来记录这个借位值。

## 11.5 OF标志
在进行**有符号数**运算的时候，如结果超过了机器所能表示的范围称为溢出。

注意，这里所讲的溢出，只是对有符号数运算而言。（就像进位只是相对于无符号数而言）

debug中标志寄存器的表示
```
标志    值为1的标记      值为0的标记
OF      OV              NV
SF      NG              PL
ZF      ZR              NZ
PF      PE              PO
CF      CY              NC
DF      DN              UP
```

CF和OF的区别：
  - CF是对无符号数运算有意义的标志位
  - OF是对有符号数运算有意义的标志位
  - 当然，还要用SF为来记录结果的符号

## 11.6 adc指令
adc是带进位加法指令，它利用了CF位上记录的进位值
  - 格式：adc 操作对象1，操作对象2
  - 功能：操作对象1=操作对象1+操作对象2+CF
  - 比如：adc ax，bx实现的功能是：(ax)=(ax)+(bx)+CF

## 11.7 sbb指令
sbb是带借位减法指令，它利用了CF位上记录的借位值。
  - 格式：sbb 操作对象1，操作对象2
  - 功能：操作对象1=操作对象1-操作对象2-CF
  - 比如：sbb ax，bx
  - 实现功能：(ax)=(ax)-(bx)-CF

## 11.8 cmp指令
cmp是比较指令，功能相当于减法指令，只是不保存结果。

cmp指令执行后，将对标志寄存器产生影响。

其他相关指令通过识别这些被影响的标志寄存器位来的值比较结果。

cmp指令：
 - 格式：cmp 操作对象1，操作对象2
 - 功能：计算操作对象1-操作对象2但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。

比如：cmp ax，ax
  - 做(ax)-(ax)的运算，结果为0，但并不在ax中保存，仅影响flagh的相关各位。

指令执行后：
  - ZF=1
  - PF=1
  - SF=0
  - CF=0
  - OF=0

比较指令的设计思路：
  - 通过做减法运算，影响标志寄存器，标志寄存器的相关位记录了比较的结果。

同add、sbb指令一样，CPU在执行cmp指令的时候，也包含两种含义：
  - 进行无符号数运算和进行有符号数运算。

所以利用cmp指令可以对无符号数进行比较，也可以对有符号数进行比较。

如果没有溢出发生的话，那么，实际结果的正负和逻辑上真正结果的正负就一致了。

所以，我们应该在考察SF（得知实际结果的正负）的同时考察OF（得知有没有溢出），就可以得知逻辑真正结果的正负，同时就可以知道比较的结果。

## 11.9 检测比较结果的条件转移指令
因为cmp指令可以同时进行两种比较，无符号数比较和有符号数比较，所以根据cmp指令的比较结果进行转移的指令也分为两种，即：
  - 根据无符号数的比较结果进行转移的条件转移指令，他们检测ZF、CF的值
  - 和根据有符号数的比较结果进行转移的条件转移指令，他们检测SF、OF和ZF的值。

```
条件转移指令小结
指令        含义            检测的相关标志位
je          等于则转移      ZF=1
jne         不等于则转移    ZF=0
jb          低于则转移      CF=1
jnb         不低于则转移    CF=0
ja          高于则转移      CF=0,ZF=0
jna         不高于则转移    CF=1或ZF=1

```

- j表示jump
- e表示equal
- n表示not
- b表示below
- a表示above

他们所检测的标志位，都是cmp指令进行无符号数比较时候，记录比较结果的标志位。

比如je，检测ZF位，当ZF=1的时候进行转移，如果在je前面使用了cmp指令，那么je对ZF的检测，实际上就是间接地检测cmp的比较结果是否为两数相等。

“相等则转移”这种逻辑含义，是通过和cmp指令配合使用来体现的，因为是cmp指令为“ZF=1”赋予了“两数相等”的含义。

## 11.10 DF标志和串传送指令
flag的第10位时DF，方向标志位。在串处理指令中，控制每次操作后si，di的增减。
  - DF=0：每次操作后si，di递增
  - DF=1：每次操作后si，di递减

movsb
  - 功能：以字节为单位传送
  - ((es)*16+(di))=((ds)*16+(si))
  - 如果DF=0，则(si)=(si)+1;(di)=(di)+1
  - 如果DF=1，则(si)=(si)-1;(di)=(di)-1

movsb的功能是将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器DF位置的值，将si和di递增或递减。

movsw
  - 功能：以字为单位传送
  - 将ds:si指向的内存单元中word送入es:di中，然后根据标志寄存器DF位的值，将si和di递增2或递减2。

movsb和movsw进行的是串传送操作中的一个步骤，一般来说，movsb和movsw都和rep配合使用，格式如下：rep movsb。

rep的作用是根据cx的值，重复执行后面的串传送指令。

由于flag的DF位决定着串传送指令执行后，si和di改变的方向，所以CPU应该提供相应的指令来对DF为进行设置，从而使程序员能够决定传送的方向。

8086CPU提供下面两条指令对DF位进行设置：
  - cld指令：将标志寄存器的DF位置0
  - std指令：将标志寄存器的DF位置1

## 11.11 pushf和popf
pushf：将标志寄存器的值压栈。

popf：从栈中弹出数据，送入标志寄存器中。

pushf和popf，为直接访问标志寄存器提供了一种方法。

# 12. 内中断
## 12.1 内中断的产生
中断时CPU处理外部突发事件的一个重要技术。

它能使CPU在运行过程中对外部事件发出的中断请求及时地进行处理，处理完成后又立即返回断点，继续进行CPU原来的工作。

外部中断一般是指计算机外设发出的终端请求，如：键盘中断、打印机中断、定时器中断等。外部中断时可以屏蔽的终端，也就是说，利用中断控制器可以屏蔽这些外部设备的中断请求。

内部中断是指因硬件出错（如突然掉电、奇偶检验错等）或运算出错（除数为零、运算溢出、单步中断等）所引起的中断。内部中断是不可屏蔽的中断。

软件中断其实并不是真正的中断，他们只是可被调用执行的一般程序以及DOS的系统功能调用(INT 21H)等都是软件中断。

CPU为了处理并发的中断请求，规定了中断的优先权，中断优先权由高到低的顺序是：
1. 除法错、溢出中断、软件中断
2. 不可屏蔽中断
3. 可屏蔽中断
4. 单步中断

## 12.2 中断处理程序
CPU的设计者必须在中断信息和其处理程序的入口地址之间建立某种联系，使得CPU根据中断信息找到要执行的处理程序。

若要定位中断处理程序，需要知道它的段地址和偏移地址，而如何根据8位的中断类型码（8086中断类型码为一个字节）得到中断处理程序的段地址和偏移地址？这就要引入中断向量表。

## 12.3 中断向量表
CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。

中断向量表在内存中存放，对于8086PC机，中断向量表指定放在内存地址0处。

从内存0000:0000到0000:03FF的1024个单元中存放着中断向量表。

## 12.4 中断过程
从上面的讲解中，我们知道，可以用中断类型码，在中断向量表中找到中断处理程序的入口。

找到这个入口地址的最终目的是用它设置CS和IP，使CPU执行中断处理程序。

用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的。

CPU硬件完成这个工作的过程被称为中断过程。

8086CPU的中断过程：
1. （从中断信息中）取得中断类型码
2. 标志寄存器的值入栈（保护标志位）
3. 设置标志寄存器的第8位TF和第9位IF的值为0；
4. CS的内容入栈
5. IP的内容入栈
6. 从内存地址为中断类型码*4和中断类型码\*4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS。

上述步骤的汇编描述：
1. 取得中断类型码N
2. pushf
3. TF=0,IF=0
4. push CS
5. push IP
6. (IP)=(N*4), (CS)=(N\*4+2)

## 12.5 中断处理程序
由于CPU随时都可能检测到中断信息，也就是说，CPU随时都可能执行中断处理程序，所以中断处理程序必须一直存储在内存某段空间之中。

而中断处理程序的入口地址，即中断向量，必须存储在对应的终端向量表表项中。

中断处理程序的编写方法和子程序的比较相似，下面是常规的步骤：
1. 保存用到的寄存器
2. 处理终端
3. 恢复用到的寄存器
4. 用iret指令返回

iret指令的功能用汇编语法描述为：
  - pop IP
  - pop CS
  - popf

iret通常和硬件自动完成的中断过程配合使用。

## 12.6 除法错误中断的处理
当CPU执行div等除法指令的时候，如果发生了除法溢出错误，将产生中断类型码为0的中断信息，CPU将检测到这个信息，然后引发中断过程，转去执行0号中断所对应的中断处理程序。

## 12.7 单步中断
CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。

CPU提供单步中断功能的原因就是，为单步跟踪的执行过程，提供了实现机制。

## 12.8 响应中断的特殊情况
一般情况下，CPU在执行完当前指令后，如果检测到中断信息，就响应中断，引发中断过程。

可是，在有些情况下，CPU在执行完当前指令后，即便是发生中断，也不会响应。

例如，在执行完向ss寄存器传送数据的指令后，即便检测到中断信号，CPU也不会响应。

这样做的主要原因是，ss:sp联合指向栈顶，而对他们的设置应该连续完成。

因为，如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和IP的值。

而ss改变，sp并未改变，ss：sp指向的不是正确的栈顶，将引起错误。

# 13. int指令
## 13.1 int指令
int格式：
  - int n，n为中断类型码。它的功能是引发中断过程。

可以在程序中使用int指令调用任何一个中断的中断处理程序。

int指令的最终功能和call指令相似，都是调用一段程序。

因此，一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用。

## 13.2 对int、iret和栈的深入理解
在中断例程中，可以从栈例取得标号s的段地址和标号se的偏移地址，而用标号se的偏移地址加上bx中存放的转移位移就可以得到标号s的偏移地址。

可以利用iret指令，我们将栈中的se的偏移地址加上bx中的转移位移，则栈中的se的偏移地址就变为了s的偏移地址。

我们再使用iret指令，用栈中的内容设置CS、IP，从而实现转移到标号s处。

## 13.3 BIOS和DOS中断例程的安装过程
1. 开机后，CPU一加电，初始化(CS)=0FFFFH,(IP)=0,自动从FFFF:0单元开始执行程序。FFFF:0处有一条转跳指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。
2. 初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记是在中断向量表中。
3. 硬件系统检测和初始化完成后，调用int 19h进行操作系统的引导。从此将计算机交由操作系统控制。
4. DOS启动后，除完成其它工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。

# 14. 端口
CPU可以直接读写三个地方的数据：
  - CPU内部的寄存器
  - 内存单元
  - 端口

## 14.1 端口的读写
对端口的读写不能用mov、push、pop等内存读写指令。

端口的读写指令只有两条：in和out分别用于从端口读取数据和往端口写入数据。

CPU执行内存访问指令和端口访问指令是，总线上的信息：
1. 访问内存
2. 访问端口

在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用al，访问16位端口时用ax。

对256~65535的端口进行读写时，端口号放在dx中。

## 14.2 CMOS RAM芯片
PC级机中的CMOS RAM芯片，其有如下特征：
1. 包含一个实时钟和一个有128个存储单元的RAM存储器。
2. 该芯片靠电池供电。因此，关机后其内部的实时钟仍可正常工作，RAM中的信息不丢失。
3. 128个字节的RAM中，内部实时钟占用0~0dh单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。
4. 该芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口读写CMOS RAM。
5. 70h为地址端口，存放要访问的CMOS RAM单元的地址；71h为数据端口，存放从选定的CMOS RAM单元中读取的数据，或要写入其中的数据。

## 14.3 shl和shr指令
shl和shr是逻辑移位指令。

shl逻辑左移指令，功能为：
1. 将一个寄存器或内存单元中的数据向左移位；
2. 将最后一处的一位写入CF中；
3. 最低位用0补充。

如果移动位数大于1时，必须将移动位数放在cl中。

shr逻辑右移指令，它和shl所进行的操作刚好相反：
  - 将一个寄存器或内存单元中的数据向右移位；
  - 将最后移出的一位写入CF中；
  - 最高位用0补充。

## 14.4 CMOS RAM中存储的时间信息
在CMOS RAM中，存放着当前时间：
  - 秒：00H
  - 分：02H
  - 时：04H
  - 日：07H
  - 月：08H
  - 年：09H
  - 这6个信息的长度都为1个字节

一个字节可表示两个BCD码。

则CMOS RAM存储时间信息的单元中，存储了用两个BCD码表示的两位十进制数，高4位的BCD码表示十位，低4位的BCD码表示个位。

# 15. 外中断
## 15.1 接口芯片和端口
在PC系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片的内部有若干寄存器，CPU将这些寄存器当做端口来访问。

外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中；

CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。

CPU还可以向外设输出控制命令，而这些控制命令也是先送到相关芯片的端口中，然后再由相关的芯片根据命令对外设实施控制。

可见，CPU通过端口和外部设备进行联系。

CPU在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入。

## 15.2 外中断信息
在PC系统中，外中断源一共有两类：
1. 可屏蔽中断
2. 不可屏蔽中断

### 15.2.1 可屏蔽中断
可屏蔽中断时CPU可以不响应的外中断。CPU是否响应可屏蔽中断，要看标志寄存器的IF位的设置。

当CPU检测到可屏蔽中断信息时：
  - 如果IF=1，则CPU在执行完当前指令后响应中断，引发中断过程。
  - 如果IF=0，则不响应可屏蔽中断。

可屏蔽中断所引发的中断过程，除在第一步的实现上有所不同外，基本上和内中断的中断过程相同。

因为可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的；

而内中断的中断类型码是在CPU内部产生的。

中断过程中将IF置为零的原因是，在进入中断处理程序后，禁止其他的可屏蔽中断。

如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF置1.

8086CPU提供的设置IF的指令如下：
  - sti，用于设置IF=1；
  - cli，用于设置IF=0。

### 15.2.2 不可屏蔽中断
不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。

对于8086CPU不可屏蔽中断的中断类型码固定为2.所以中断过程中，不需要取中断类型码。

不可屏蔽中断的中断过程：
1. 标志寄存器入栈，IF=0，TF=0；
2. CS、IP入栈；
3. (IP)=(8),(CS)=(0AH)

几乎所有由外设引发的外中断，都是可屏蔽中断。当外设有需要处理的事件（比如说键盘输入）发生时，相关芯片向CPU发出可屏蔽中断信息。

不可屏蔽中断是在系统中有必须处理的紧急情况发生时用来通知CPU的中断信息。

## 15.3 PC机键盘的处理过程
PC机处理外设输入的基本方法：
1. 键盘输入
2. 引发9号中断
3. 执行int 9中断例程

键盘上的每一个键相当于一个开关，键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描。

按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。扫描码被送入主板上的相关接口芯片的寄存器，该寄存器的端口地址为60H。

松开按下的键时，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置。松开按键时产生的扫描码也被送入60H端口中。

一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。

扫描码长度为一个字节，通码的第7位为0，断码的第7位为1，即：
  - 断码 = 通码 + 80H

BIOS提供了int 9中断例程，用来进行基本的键盘输入处理，主要的工作如下：
  - 读出60H端口中的扫描码
  - 如果是字符键的扫描码，将该扫描码和它所对应的字符码送入内存中的BIOS键盘缓冲区；
  - 对键盘系统进行相关的控制，比如，向相关芯片发出应答信息。

如果是控制键（比如ctrl）和切换键（比如capslock）的扫描码，则将其转变为转台字节写入内存中存储状态字节的单元。

# 16. 直接定址表
## 16.1 描述了单元长度的标号
我们还可以使用一种标号，这种标号不但表示内存单元的地址，还表示了内存单元的长度，即表示在此标号处的单元，是一个字节单元，还是字单元，还是双字单元。

在使用的标号后面没有":"，因此他们是可以同时描述内存地址和单元长度的标号。
```
code segment
  a db 1,2,3,4,5,6,7,8
  b dw 0
```

标号a，描述了地址code:0，和从这个地址开始，以后的内存单元都是字节单元；

而标号b描述了地址code:8，和从这个地址开始，以后的内存单元都是字单元。

因为这种标号包含了对单元长度的描述，所以，在指令中，它可以代表一个段中的内存单元。

比如，对于程序中的b dw 0：
  - 指令mov ax，b相当于：mov ax，cs:[8]
  - 在指令中，标号b代表了一个内存单元，地址为code:8，长度为2字节。

这种标号称为数据标号，他标记了存储数据的单元的地址和长度，它不同于仅仅表示地址的地址标号。

## 16.2 在其他段中使用数据标号
一般来说，我们不会再代码段中定义数据，而是将数据定义到其他段中。

在其他段中，我们也可以使用数据标号来描述存储数据的单元的地址和长度。

**注意：**在后面加有":"的地址标号，只能在代码段中使用，不能在其他段中使用。<br>
如果想在代码段中，直接用户数据标号访问数据，则需要用伪指令assume将标号所在的段和一个段寄存器联系起来。

我们可以将标号当做数据来定义，此时，编译器将标号所表示的地址当做数据的值。
比如：
```
data segment
    a db 1,2,3,4,5,6,7,8
    b dw 0
    c dw a,b
data ends
```

数据标号c处存储的两个字型数据为标号a、b的偏移地址。

## 16.3 直接定址表
利用表，在两个数据集合之间建立一种映射关系，使我们可以用查表的方法根据给出的数据得到其在另一集合中的对应数据。

这样做的目的一般来说有三个：
1. 为了算法的清晰和简洁。
2. 为了加快运算速度。
3. 为了使程序易于扩充。

具体的查表方法，使用查表的依据数据，直接计算出所要查找的元素在表中的位置。

像这种可以通过依据数据，直接计算出所要找的元素的位置的表，我们称其为：直接定址表。

我们可以在直接定址表中存储子程序的地址，从而方便地实现不同子程序的调用。

# 17. 使用BIOS进行键盘输入和磁盘读写
## 17.1 int 9中断例程对键盘输入的处理
CPU在9号中断发生后，执行int 9中断例程，从60h端口读出扫描码，并将其转化为相应的ASCII码或状态信息，存储在内存的指定空间中。

所以，一般的键盘输入，在CPU执行完int 9中断例程后，都放到了键盘缓冲区中。

键盘缓冲区中有16个字单元，可以存储15个按键的扫描码和对应的ASCII码。

## 17.2 使用int 16h中断例程读取键盘缓冲区
BIOS提供了int 16h中断例程供程序员调用。

int 16h中断例程中包含的一个最重要的功能是从键盘缓冲区中读取一个键盘输入，该功能的编号为0.

int 16h中断例程的0号功能，进行如下的工作：
1. 检测键盘缓冲区中是否有数据；
2. 没有则继续做第1步；
3. 读取缓冲区第一个字单元中的键盘输入；
4. 将读取的扫描码送入ah，ASCII码送入al；
5. 将已读取的键盘输入从缓冲区中删除。

可见，BIOS的int 9中断例程和int 16h中断例程是一对相互配合的程序，int 9中断例程向键盘缓冲区中写入，int 16h中断例程从缓冲区中读出。

它们写入和读出的时机不同，int 9中断例程在有键按下的时候向键盘缓冲区中写入数据；

而int 16h中断例程是在应用程序对其进行调用的时候，将数据从键盘缓冲区中读出。

## 17.3 字符串的输入
最基本的字符串输入程序，需要具备下面的功能：
1. 在输入的同时需要显示这个字符串；
2. 一般在输入回车符后，字符串输入结束；
3. 能够删除已经输入的字符。

字符串输入的过程中，字符的输入和输出是按照栈的访问规则进行的，即后进先出。

这样，我们就可以用栈的方式来管理字符串的存储空间，也就是说，字符串的存储空间实际上是一个字符栈。

- 字符栈中的所有字符，从栈底到栈顶，组成一个字符串。
- 在输入回车符后，字符串输入结束
- 在输入的同时需要显示这个字符串
- 程序处理过程：
  1. 调用int 16h读取键盘输入
  2. 如果是字符，进入字符栈，显示字符栈中的所有字符；继续执行1。
  3. 如果是退格键，从字符栈中弹出一个字符，显示字符栈中的所有字符；继续执行1；
  4. 如果是enter键，向字符栈中压入0，返回。

从程序的处理过程中可以看出，字符栈的入栈、出栈和显示栈中的内容，是需要在多出使用的功能，我们应该将它们写为子程序。

## 17.4 应用int 13h中断例程对磁盘进行读写
常用的3.5英寸软盘的结构：
  - 分为上下两面，每面有80个磁道，每个磁道又分为18格栅渠，每个扇区的大小为512B。
  - 总容量为：2*80*18*512B=1440KB=1.44MB

我们只能以扇区为单位对磁盘进行读写。在读写扇区的时候，要给出面号、磁道号和扇区号。面号和磁道号从0开始，而扇区号从1开始。

BIOS提供了对扇区进行读写的终端例程，这些中断例程完成了许多复杂的和硬件相关的工作。

我们可以通过调用BIOS中断例程来访问磁盘。
